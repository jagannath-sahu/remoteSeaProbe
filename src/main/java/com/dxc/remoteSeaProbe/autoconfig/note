# 0Ô∏è‚É£ First: when do you REALLY need auto-configuration?

Auto-configuration is **NOT** for:

* Your normal application beans
* Controllers, services, repos
* Internal logic

Auto-configuration **IS** for:

* Libraries / shared modules
* Starters (`spring-boot-starter-*`)
* Infrastructure setup
* Conditional wiring

### Real examples:

* `DataSourceAutoConfiguration`
* `KafkaAutoConfiguration`
* `RedisAutoConfiguration`
* `JpaRepositoriesAutoConfiguration`

Rule of thumb:

> If users of your code should ‚Äújust add a dependency and it works‚Äù, you need auto-config.

---

# 1Ô∏è‚É£ What auto-configuration REALLY is (mental model)

Auto-configuration is just:

```java
@Configuration
@Conditional(...)
public class SomethingAutoConfiguration {
    @Bean
    ...
}
```

Nothing magical.

Spring Boot:

* Scans auto-config classes
* Evaluates conditions
* Registers beans **only if conditions match**

---

# 2Ô∏è‚É£ Let‚Äôs build a REAL auto-configuration (hands-on lab)

We‚Äôll create:

> **RemoteSeaProbe Starter** that auto-configures a probe client

You‚Äôll be able to:

* Add dependency
* Get bean automatically
* Override it
* See it in `/actuator/beans`

---

## Step 1Ô∏è‚É£ Create a new package (IMPORTANT separation)

```text
com.dxc.remoteSeaProbe.autoconfig
```

Never put auto-config in your normal `service` package.

---

## Step 2Ô∏è‚É£ Create a simple service (library-style)

```java
package com.dxc.remoteSeaProbe.core;

public class ProbeClient {

    private final String endpoint;

    public ProbeClient(String endpoint) {
        this.endpoint = endpoint;
    }

    public String ping() {
        return "Pinging " + endpoint;
    }
}
```

No Spring annotations here ‚ùå
This simulates a **real library class**.

---

## Step 3Ô∏è‚É£ Create configuration properties (VERY IMPORTANT)

```java
package com.dxc.remoteSeaProbe.autoconfig;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "probe")
public class ProbeProperties {

    private String endpoint = "http://localhost:9999";

    public String getEndpoint() {
        return endpoint;
    }

    public void setEndpoint(String endpoint) {
        this.endpoint = endpoint;
    }
}
```

‚úî Externalized config
‚úî IDE autocomplete
‚úî Type-safe

---

## Step 4Ô∏è‚É£ Create the Auto-Configuration class

```java
package com.dxc.remoteSeaProbe.autoconfig;

import com.dxc.remoteSeaProbe.core.ProbeClient;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@EnableConfigurationProperties(ProbeProperties.class)
@ConditionalOnProperty(prefix = "probe", name = "enabled", havingValue = "true", matchIfMissing = true)
public class ProbeAutoConfiguration {

    @Bean
    @ConditionalOnMissingBean
    public ProbeClient probeClient(ProbeProperties properties) {
        return new ProbeClient(properties.getEndpoint());
    }
}
```

### Read this CAREFULLY:

* `@ConditionalOnProperty` ‚Üí user can disable it
* `@ConditionalOnMissingBean` ‚Üí user can override
* `@EnableConfigurationProperties` ‚Üí binds config

This is **exactly how Spring Boot does it**.

---

# 5Ô∏è‚É£ Register auto-configuration (THIS IS CRITICAL)

### Spring Boot 3.x+

Create file:

```text
src/main/resources/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports
```

Add:

```text
com.dxc.remoteSeaProbe.autoconfig.ProbeAutoConfiguration
```

‚ö†Ô∏è Without this file, auto-config WILL NOT load.

---

# 6Ô∏è‚É£ Test it in your SAME project (local lab)

### application-local.yml

```yaml
probe:
  enabled: true
  endpoint: http://remote-sea-probe
```

---

### Inject and test

```java
@Component
@Profile("local")
public class ProbeTestRunner implements CommandLineRunner {

    private final ProbeClient probeClient;

    public ProbeTestRunner(ProbeClient probeClient) {
        this.probeClient = probeClient;
    }

    @Override
    public void run(String... args) {
        System.out.println(probeClient.ping());
    }
}
```

Expected output:

```text
Pinging http://remote-sea-probe
```

üéâ You just wrote real auto-configuration.

---

# 7Ô∏è‚É£ Verify using Actuator (DO THIS)

```bash
/actuator/beans
```

Search for:

```text
probeClient
ProbeAutoConfiguration
```

And:

```bash
/actuator/conditions
```

You‚Äôll see:

* Why it matched
* Which condition enabled it

---

# 8Ô∏è‚É£ Test override behavior (IMPORTANT)

### User defines own bean:

```java
@Configuration
public class CustomProbeConfig {

    @Bean
    public ProbeClient probeClient() {
        return new ProbeClient("custom-endpoint");
    }
}
```

Result:

* Auto-config backs off
* Your bean wins

‚úî This is **mandatory for good starters**

---

# 9Ô∏è‚É£ When auto-configuration surprises people

Common causes:

* Classpath condition matched unexpectedly
* Property default `matchIfMissing = true`
* Bean already exists
* Profile not active

This is why `/actuator/conditions` exists.

---

# üîü Interview-level explanation

**Q:** Why use auto-configuration instead of normal `@Configuration`?

**A:**

> Auto-configuration allows conditional, opt-in bean creation based on classpath, properties, and existing beans, enabling libraries to integrate seamlessly without explicit configuration.

---

# üî• Golden rules (WRITE THESE)

1. Auto-config lives in **separate package/module**
2. Always allow override (`@ConditionalOnMissingBean`)
3. Always provide properties
4. Always document disable switch
5. Always verify with Actuator

---

# Next things (high value)

If you want, next we can:

* Split this into a **real starter module**
* Add `@ConditionalOnClass`
* Add tests using `ApplicationContextRunner`
* Debug auto-config order
* Write failure analyzer

Just tell me üëç
